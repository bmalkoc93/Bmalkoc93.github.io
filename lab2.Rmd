---
title: "Lab 2: Spatial Data in R"
subtitle: <h4 style="font-style:normal">CRD 298 - Spatial Methods in Community Research</h4>
author: <h4 style="font-style:normal">Professor Noli Brazil</h4>
date: <h4 style="font-style:normal">January 16, 2019</h4>
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: cosmo
    code_folding: show
---


<style>
p.comment {
background-color: #DBDBDB;
padding: 10px;
border: 1px solid black;
margin-left: 25px;
border-radius: 5px;
font-style: italic;
}

h1.title {
  font-weight: bold;
}

</style>
\

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


In this guide you will to acquire the skills needed to process and present spatial data in R.  The objectives of the guide are as follows 


1. Understand how spatial data are processed in R.
2. Learn spatial operations on polygon shapefile data.
3. Learn how to use areal interpolation to attach census data to non census boundaries.
4. Learn how to make a map.


This lab guide follows closely and supplements the material presented in Chapters 2.1, 4.2, and 8 in the textbook [Geocomputation with R](https://geocompr.robinlovelace.net/) (GWR).  This guide focuses exclusively on polygon data.  You will have the opportunity to handle and examine point data in Lab 3.

<div style="margin-bottom:25px;">
</div>
## **Installing and loading packages**
\

You'll need to install the following packages in R.  You only need to do it once, so if you've already installed these packages, skip the code.  Also, don't put these `install.packages()` in your R Markdown document.  Copy and paste the code in the R Console.

```{r warning = FALSE, message = FALSE, eval = FALSE}
install.packages("rmapshaper")
install.packages("tigris")
install.packages("sf")
install.packages("tmap")
```

You'll need to load the following packages.  Unlike installing, you will *always* need to load packages whenever you start a new R session. You'll also always need to use `library()` in your R Markdown file.  We'll talk about what these packages provide as their relevant functions come up in the guide.

```{r warning = FALSE, message = FALSE}
library(tidyverse)
library(tidycensus)
library(sf)
library(tigris)
#you need to let R know to bring in the spatial data as sf objects
options(tigris_class = "sf")
library(rmapshaper)
library(tmap)
```

<div style="margin-bottom:25px;">
</div>
## **Spatial data in R**
\

There are two main packages for dealing with spatial data: **sp** and **sf**.

* **sp** has been around since 2005, and thus has a rich ecosystem of tools built on top of it. However, it uses a rather complex data structure, which can make it challenging to use.
* **sf** is newer (first released in 2016!) so it doesn’t have such a rich ecosystem. However, it’s much easier to use and fits in very naturally with the tidyverse.  The trend is gradually shifting towards the use of **sf** as the primary spatial package.

Processing spatial data is very similar to nonspatial data thanks to the package **sf**, which is *tidy friendly*.  The non-tidy package **sp** is still used quite a bit, and you'll be relying on this package to do more complicated spatial analyses in future labs.  

**sf** stands for simple features.  What is a feature? A feature is thought of as a thing, or an object in the real world, such as a building or a tree.  A county can be a feature. As can a city and a neighborhood.  The [Simple Features standard](https://en.wikipedia.org/wiki/Simple_Features) defines a simple feature as a representation of a real world object by a point or points that may or may not be connected by straight line segments to form lines or polygons.  Features have a geometry describing where on Earth the features are located, and they have attributes, which describe other properties. Think back to Lab 1 - we were working with census tracts.  The difference between what we were doing last week and what we will be doing in this lab is that tracts in Lab 1 had attributes (e.g. percent Hispanic, total population), but they did not have geometries. This is what separates nonspatial and spatial data in R.  

<div style="margin-bottom:25px;">
</div>
## **Bringing in spatial data**
\

We'll be primarily working with object (or vector) data in shapefile format in this class.  There are two major packages for bringing in Census shapefiles into R: **tidycensus** and **tigris**.  These packages allow users to directly download and use [TIGER Line shapefiles](https://www.census.gov/geo/maps-data/data/tiger-line.html) from the Census Bureau.

<div style="margin-bottom:25px;">
</div>
### **tidycensus**
\

In Week 1's lab, we worked with the **tidycensus** package and the Census API to bring in Census data into R.  We can use the same commands to bring in Census geography.  Use the `get_acs()` command to bring in California tract-level median household income.  Remember to use your Census API key.  

```{r include=FALSE, warning=FALSE, results="hide"}
census_api_key("b81d373d6e785ecbc489de1fc862aef424d0a63a")
```

```{r eval=FALSE, warning=FALSE, results="hide"}
census_api_key("YOUR API KEY GOES HERE")
```

```{r warning=FALSE, results="hide", message=FALSE}
ca.tracts <- get_acs(geography = "tract", 
              year = 2016,
              variables = c(medincome = "B19013_001", totp = "B01003_001",
                            tothhs = "B11001_001"), 
              state = "CA",
              survey = "acs5",
              geometry = TRUE)
```

The only difference between the code above and what we used in Week 1 is we have one additional argument added to the `get_acs()` command: `geometry = TRUE`.  This tells R to bring in the spatial features associated with the geography you specified in the command, in the above case California tracts. Type in *ca.tracts* to see what we've got.

```{r}
ca.tracts
```

The object looks much like a basic tibble, but with a few differences.  

* You'll find that the description of the object now indicates that it is a simple feature collection with 8,041 features (census tracts) with 5 fields (attributes or columns of data).  
* The `geometry_type` indicates that the spatial data are in `MULTIPOLYGON` form (as opposed to points or lines, the other basic vector data forms).  
* `bbox` stands for bounding box, which indicates the spatial extent of the features (from left to right, for example, California tracts go from a longitude of -124.4096 to -114.1312).  
* `epsg` and `proj4string` are related to the coordinate reference system, which we'll touch on later in the quarter.  
* The final difference is that the data frame contains the column *geometry*.  The tidy data rule for simple features is: we have a `data.frame` where each feature forms a row. A single column (a list-column) contains the geometry for each observation.  Remember that a tibble is a `data.frame`. 

At its most basic, an **sf** object is a collection of simple features that includes attributes and geometries in the form of a data frame. In other words, it is a data frame (or tibble) with rows of features, columns of attributes, and a special geometry column that contains the spatial aspects of the features. 

If you want to peek behind the curtain and learn more about the nitty gritty details about simple features, check out the official **sf** [vignette](https://r-spatial.github.io/sf/articles/sf1.html#geometrycollection). 


<div style="margin-bottom:25px;">
</div> 
### **tigris package**
\

Another package that allows us to bring in census geographic boundaries is **tigris**.  [Here](https://github.com/walkerke/tigris/blob/master/README.md) is a list of all the boundaries you can download through this package.  When you loaded in the **tigris** package, you had to specify the option `tigris_class = "sf"` to tell R to bring in shapefiles as **sf** objects (the default is to bring them as **sp** objects)

Let's use the function `core_based_statistical_areas()` to bring in boundaries for all metropolitan areas in the United States.

```{r warning=FALSE, message=FALSE, results = FALSE}
cb <- core_based_statistical_areas(cb = TRUE)
```

The `cb = TRUE`  argument tells R to download a [generalized cartographic boundary](https://www.census.gov/geo/maps-data/data/cbf/cbf_description.html) file, which drastically reduces the size of the data (compare the file size when you don't include `cb = TRUE`) .  Then use `filter()` to keep the Sacramento metropolitan area.  In order to do this, we can use the function `grepl()` within the `filter()` function. 

```{r}
sac.metro <- filter(cb, grepl("Sacramento", NAME))
```

The function `grepl()` tells the command `filter()` to find features (rows) with the value "Sacramento" somewhere in their value for the variable *NAME*. This is useful when we don't know the exact name of an area.

Let's also bring in the boundaries for Sacramento city.  Use the `places()` function to get all places in California.

```{r warning=FALSE, message=FALSE, results = FALSE}
pl <- places(state = "CA", cb = TRUE)
```

Then use `filter()` to keep Sacramento.

```{r warning=FALSE, message=FALSE, results = FALSE}
sac.city <- filter(pl, NAME == "Sacramento")
```

I use `NAME ==` here instead of `grepl()` because I didn't want to include West Sacramento.  Note that unlike the **tidycensus** package, **tigris** does not allow you to attach attribute data (e.g. percent Hispanic, total population, etc.) to geometric features.

<div style="margin-bottom:25px;">
</div> 
### **Reading from your hard drive**
\

Directly reading spatial files using an API is great, but doesn't exist for many spatial data sources. You'll often have to download a spatial data set, save it onto your hard drive and read it into R.  The function for reading spatial files is `st_read()`.

I downloaded a Sacramento Council Districts shapefile from Sacramento's [open data portal](http://data.cityofsacramento.org/).  I zipped up the file and uploaded it onto Github.  Set your working directory to an appropriate folder and use the following code to download and unzip the file.

```{r warning = FALSE, message = FALSE, eval = FALSE}
setwd("insert your pathway here")
download.file(url = "https://raw.githubusercontent.com/crd230/data/master/Council_Districts.zip", destfile = "Council_Districts.zip")
unzip(zipfile = "Council_Districts.zip")
```

```{r warning = FALSE, message = FALSE, include = FALSE}
download.file(url = "https://raw.githubusercontent.com/crd230/data/master/Council_Districts.zip", destfile = "Council_Districts.zip")
unzip(zipfile = "Council_Districts.zip")
```

You should see the *Council_Districts* files in your folder. Bring in the council district boundary file using `st_read()`.  You'll need to add the *.shp* extension so that the function knows it's reading in a shapefile.

```{r warning = FALSE, message = FALSE, results = "hide"}
cdist <- st_read("Council_Districts.shp")
```

We'll be using *cdist* a little later in the guide.

<div style="margin-bottom:25px;">
</div>
## **Data Wrangling**
\

There is a lot of stuff [behind the curtain](https://www.jessesadler.com/post/simple-feature-objects/) of how R handles spatial data as simple features, but the main takeaway is that **sf** objects are data frames.  This means you can use many of the functions we've learned in the past lab to manipulate **sf** objects, including the pipe `%>%` operator. For example, let's do the following data wrangling tasks on *ca.tracts*.

1. Drop the *moe* variable
2. Convert the dataset from long to wide
3. Break up the column *NAME* into separate tract, county and state variables

We do all of this in one line of continuous code using the pipe operator `%>%`

```{r}
ca.tracts <- ca.tracts %>%
              select(-(moe)) %>%
            spread(key = variable, value = estimate) %>%
            separate(NAME, into = c("tract", "county", "state"), sep=", ")
```


The main point: **sf** objects are data frames, so you can use many of the functions you've learned in the past couple of labs on these objects.  This includes the function `ggplot()`, which we can use to map the data. We'll go into more detail on how to use `ggplot()` for mapping later in this guide, so for now just type in

```{r}
ggplot(ca.tracts) + geom_sf()
```

You've made your first map in R (at least in my class). Whoopee! 

If you are getting an error about R not being able to find the function `geom_sf()` see [here](https://stackoverflow.com/questions/46817128/error-could-not-find-function-geom-sf?rq=1) for some guidance.

<div style="margin-bottom:25px;">
</div>
## **Spatial Data Wrangling**
\

There is Data Wrangling and then there is *Spatial Data Wrangling*.  Spatial Data Wrangling involves cleaning or altering your data set based on the geographic location of features. The **sf** package offers a suite of functions unique to wrangling spatial data.  Most of these functions start out with the prefix `st_`.  To see all of the functions, type in

```{r, results="hide"}
methods(class = "sf")
```

We won't go through all of these functions as the list is quite extensive.  You can take a look at Chapter 4 of GWR to see some examples of these functions.  But, let's go through some of the more important ones.  


<div style="margin-bottom:25px;">
</div>
### **Subset: Intersect and Within**
\

A common spatial data wrangling issue is to subset a set of spatial objects based on their location relative to another spatial object.  In our case, we want to keep California tracts that are in the Sacramento metro area.  We can do this using the `st_join()` function and specify  `join = st_intersects` 

```{r warning=FALSE, message=FALSE, results = "hide"}
sac.metro.tracts.int <- st_join(ca.tracts, sac.metro, join = st_intersects, left=FALSE)
```

The argument `left=FALSE` tells R to just keep the  tracts that intersects *sac.metro*.  Plotting our tracts, we get

```{r}
ggplot() + 
  geom_sf(data = sac.metro.tracts.int, fill = "blue") +
  geom_sf(data = sac.metro, fill = NA, color = "red")
```

Don't get stuck on what the code is doing because we'll go through mapping with `ggplot()` later.  Focus on the map, which shows the tracts we kept using `st_intersects` (blue polygons) and the Sacramento metropolitan area (red border). 

Do you see an issue with the tracts?  `st_intersects` returns all tracts that touch *sac.metro*, which include those that touch the metro's boundary. So, we have tracts that are not actually inside the metro area boundaries (but touch them). Not good. We can instead use  `st_within` to return tracts that are completely *within* the metro. 

```{r warning=FALSE, message=FALSE}
# subset ca.tracts to those in sac.metro
sac.metro.tracts.w <- st_join(ca.tracts, sac.metro, join = st_within, left=FALSE)
ggplot() + 
    geom_sf(data = sac.metro.tracts.w, fill = "blue") +
    geom_sf(data = sac.metro, fill = NA, color = "red")
```

Now it works! Hurrah! Huzzah!

The function includes all the variables from *sac.metro*. We don't need these variables, so use `select()` to filter them out.  You'll also notice that if variables share the same name, R will keep both and attach a *.x* and *.y* to the end. For example, *GEOID* was found in both *ca.tracts* and *sac.metro*

```{r}
names(sac.metro.tracts.w)
```

Keep the necessary variables and rename *GEOID.x* back to *GEOID*.

```{r warning=FALSE, message=FALSE}
sac.metro.tracts.w <- sac.metro.tracts.w %>%
      select(GEOID.x:totp) %>%
      rename(GEOID = "GEOID.x")
```


<div style="margin-bottom:25px;">
</div>
### **Subset: Clipping**
\

Census tracts neatly fall within a metropolitan area's boundary, as it does for counties.  In other words, tracts don't spill over.  But, it does spill over for cities (remember the census geography hierarchy diagram from lecture).  The left diagram in Figure 1 is an example of a metro area in red and tracts in black - all the tracts fall neatly into the metro boundary.  In contrast, the right diagram is an example of a city - one tract falls neatly inside (top left), but the other three spill out.


<center>
![Figure 1: Tracts falling in (Metro) and out (City) of boundaries](/Users/noli/Documents/UCD/teaching/CRD 230/Lab/crd230.github.io/example1.png)

</center>

If we use `st_join()` with `st_within` for Sacramento city, we'll produce the following plot

```{r warning=FALSE, message=FALSE}
sac.city.tracts.w = st_join(ca.tracts, sac.city, join = st_within, left=FALSE)
ggplot() + 
  geom_sf(data = sac.city.tracts.w, fill = "blue") +
  geom_sf(data = sac.city, fill = NA, color = "red") 
```

The blue polygons are the tracts we kept.  You'll notice that it is empty around some of the edges of the city's boundary.  In these cases, only portions of census tracts boundaries are within the boundary. `st_within` keeps tracts only if they are *completely within* the boundary.  This is not good when tracts do not neatly fall within a boundary.

One way of dealing with this is to clip the portion of the tract that is inside the boundary.  Clipping will keep just the portion of the tract inside the city boundary and discards the rest of the tract.  We use the function, `ms_clip()` which is in the [**rmapshaper** package](https://cran.r-project.org/web/packages/rmapshaper/rmapshaper.pdf).


```{r warning=FALSE, message=FALSE}
sac.city.tracts.c <- ms_clip(target = ca.tracts, clip = sac.city, remove_slivers = TRUE)
ggplot() + 
  geom_sf(data = sac.city.tracts.c, fill = "blue") +
  geom_sf(data = sac.city, fill = NA, color = "red")
```

Now, the city is filled in with tracts. To be clear what a clip is doing, Figure 2 shows a clip of the city example shown in Figure 1.  With a clip, one tract is not clipped because it falls completely within the city (the top left tract). But, the other three are clipped - the portions that are within the boundary are kept (in blue), and the rest (with hash marks) are discarded from the map.

<center>
![Figure 2: Clipping tracts](/Users/noli/Documents/UCD/teaching/CRD 230/Lab/crd230.github.io/clip.png)

</center>

<div style="margin-bottom:25px;">
</div>
### **Areal Interpolation**
\

The traditional measure of neighborhood in the United States is the census tract.  However, other non-Census boundary definitions exist.  Examples include school attendance boundaries, electoral boundaries, and police districts. More often than not, these boundaries won't have demographic information attached to them.  Moreover, census tracts (or blocks) are not completely nested inside, so you can't just simply add them up. The problem is we want to attach resident characteristics derived from the census to these non-traditional boundaries. Areal interpolation is a common method for dealing with this issue.  

Let's use Sacramento Council Districts, the main local governing body in the city, as an example. There are [eight districts](https://www.cityofsacramento.org/Mayor-Council) in Sacramento and tracts do not neatly nest within these districts.  Some tracts overlap two or more districts.  The goal is to estimate the total population and median household income of council districts.  Areal interpolation matches census tract data to districts using the following general steps:

1.  All your demographic variables should be counts where possible.  That is, you will be interpolating the number of black residents not percent black.  For variables that you cannot get counts for like median household income, you'll have to convert it to an aggregate count. For median household income, this would involve multiplying median income by total households to get a count of total income dollars.
2. Calculate the proportion of the tract that is within a district.  This is your areal interpolation weight.
    + If tract 1's area is 1,000 and half of the tract is in district 1 and the other half is in district 2, then tract 1-district 1 and tract 1-district 2 have weights of 0.5.
3. Multiply the count characteristics by the areal interpolation weight.  
    + If tract 1's total black population is 1,000, you would multiply 1,000 by 0.5.  You are allocating 500 of tract 1's black population to district 1 and the other 500 to district 2. 
4. Sum up each tract's contribution to the district to get the areal weighted estimated count for that district.
    + If district 1 also contains tract 2, and tract 2's total black population is 500 and its areal weight is 0.25, then the black population from tract 2 that is allocated to district 1 is 500 x 0.25 = 125.  District 1's total black population is then 500 + 250 = 750.

We already downloaded and brought into R a council district shapefile. Map it to see if we've got the goods.

```{r warning = FALSE, message = FALSE, results = "hide"}
ggplot(cdist) + geom_sf() 
```

Super.

In order to proceed, we need to have the *ca.tracts* and *cdist* data sets in the same Coordinate Reference System (CRS). Don't worry yet about what this means - we will cover it in the next lab.  If you are curious, I uploaded a pdf - Coordinate_Reference_Systems.pdf - in the Week 2 Lab folder on Canvas in case you want to jump ahead and find out what a CRS is. We're going to use UTM Zone 10/NAD83 as the CRS for both features.  To change the CRS of spatial data (known as reprojecting), use the `st_transform()` function.

```{r}
ca.tracts <- st_transform(ca.tracts, crs = "+proj=utm +zone=10 +datum=NAD83 +ellps=GRS80")
cdist <- st_transform(cdist, crs = "+proj=utm +zone=10 +datum=NAD83 +ellps=GRS80")
```

Note that the only spaces allowed when specifying the `crs` is in between each argument.  For example, there should be no space in between `+` and `datum` or `datum` and `=` or `=` and `NAD83`.  They should be all together.  On the other hand, there should be a space between `NAD83` and `+ellps=GRS80`.

Next we need to transform medians, ratios, rates, and any other non count variables. We do so by multiplying median income by the total number of households (`tothhs*medincome`) to get an aggregate income measure - think of it as the total amount of income dollars in the tract.

```{r warning = FALSE, message = FALSE}
ca.tracts<-mutate(ca.tracts, incagg = tothhs*medincome)
```

We then use the function `st_interpolate_aw()` which is described in GWR Ch. 4.2.5 to perform the interpolation.  The first argument in the function is the tracts only with variables you want to interpolate, the second argument is the council districts, and the final argument (`extensive = `) is whether the interpolation sums up values (TRUE) or takes the mean (FALSE).  First, keep just the variables you want to interpolate.

```{r warning = FALSE, message = FALSE}
#keep the variables you want to interpolate
sac.city.tracts.temp <-ca.tracts %>% 
                        select(tothhs, totp, incagg)
```

Then use `st_interpolate_aw()`.

```{r warning = FALSE, message = FALSE}
cdist.sum <- st_interpolate_aw(sac.city.tracts.temp, cdist, extensive=TRUE)
```

We have an aggregate income measure - the total amount of money residing in each district. We’ll want an average measure - so, divide the total number of dollars by the number of households in the district.

```{r}
cdist.sum <- mutate(cdist.sum, medinc = incagg/tothhs)
```

Were done!  Go ahead, click it.

<center>
![](/Users/noli/Documents/UCD/teaching/CRD 230/Lab/crd230.github.io/easy.jpg)

</center>



<div style="margin-bottom:25px;">
</div>
## **Merging attribute data**
\

Another important operation is to join attribute data to an **sf** object.  For example, let's say you wanted to add tract level percent race/ethnicity, which is located in a csv file I've uploaded on GitHub

```{r warning=FALSE, message=FALSE}
ca.race <- read_csv("https://raw.githubusercontent.com/crd150/data/master/ca_race_tracts_2016.csv")
```

Remember, were dealing with data frames here, so we can use `left_join()`, which we covered in [Lab 1](https://crd230.github.io/lab1.html), to join the files *ca.race* and *sac.city.tracts.c*

```{r results = "hide"}
sac.city.tracts.c <- sac.city.tracts.c %>%
  left_join(ca.race, by = "GEOID") %>%
  select(-(NAME))
sac.city.tracts.c
```  

What if we want to merge attribute data from one shapefile into another shapefile? In this case, you can't use `left_join()`.  Instead, you use the **sf** specific function `st_join()`, which we used a little earlier to subset California tracts to those in the Sacramento metropolitan area.  To demonstrate this function, let's bring in census tract median housing value for all California tracts using the Census API.

```{r, warning=FALSE, message=FALSE}
ca.mhval <- get_acs(geography = "tract", 
              year = 2016,
              variables = c(medhval = "B25077_001"), 
              state = "CA",
              survey = "acs5",
              geometry = TRUE) %>%
            select(estimate, GEOID) %>%
            rename(medhval = estimate)
```              

Then clip it to Sacramento city boundaries using `ms_clip()`

```{r warning = FALSE, message = FALSE}
sac.city.mhval <- ms_clip(ca.mhval, sac.city, remove_slivers = TRUE)
```

If we use `left_join()` to merge *medhval* from *sac.city.mhval* into *sac.city.tracts.c*, we get an error

```{r error=TRUE}
sac.city.tracts.c <- sac.city.tracts.c %>%
  left_join(sac.city.mhval, by = "GEOID")
```

The error tells us to use `st_join()`.  Fine, let's use it then

```{r warning = FALSE, message = FALSE, results = "hide"}
sac.city.tracts.c <- sac.city.tracts.c %>%
  st_join(sac.city.mhval, join = st_equals) %>%
  select(-(GEOID.y))
sac.city.tracts.c 
```


<div style="margin-bottom:25px;">
</div>
## **Saving shapefiles**
\

To save an **sf** object, we use the function `st_write()` and specify at least two arguments, the object and a file name in quotes with the file extension. You'll also need to specify `delete_layer = TRUE` which overwrites the existing file if it already exists.  Make sure you've set your directory to the folder you want your file to be saved in.  Type in `getwd()` to see your current directory and use `setwd()` to set the directory.

```{r message=FALSE, results = "hide"}
st_write(sac.city.tracts.c, "saccitytracts.shp", delete_layer = TRUE)
```

You can save your **sf** object in a number of different data formats other than `shp`.  We won't be concerned too much with these other formats, but you can see a list of them [here](https://www.gdal.org/ogr_formats.html).

<div style="margin-bottom:25px;">
</div>
## **Mapping in R**
\

There are several functions in R that can be used for mapping.  We won't go through all of them, but GWR outlines the range of mapping packages available in Table 8.1.  We'll go through two of them: **ggplot2** and **tmap**.

<div style="margin-bottom:25px;">
</div>
### **ggplot**
\

We used `ggplot()` above to put our tracts on a map.  The way `ggplot()` works for mapping is similar to when we used it for making graphs.  `ggplot()` is the foundation and we add elements to it using other functions.  Recall from Lab 1 the basic `ggplot()` template

`````r ''`
ggplot(data = <DATA>) +
      <GEOM_FUNCTION>(mapping = aes())
````

For mapping purposes,  `geom_sf()` is `<GEOM_FUNCTION>()`.  Unlike with functions like `geom_histogram()` and `geom_boxplot()`, we don't specify an x and y axis.  Instead you use `fill` if you want to map a variable or `color` to just map boundaries.

Let's use `ggplot()` to make a [choropleth](http://wiki.gis.com/wiki/index.php/Choropleth_map) map.  We need to specify a numeric variable in the `fill =` argument within `geom_sf()`. 

```{r}
ggplot(sac.city.tracts.c) +
  geom_sf(aes(fill = medincome))
``` 

Why is *sac.city.tracts.c* specified within `ggplot()` whereas earlier it was used within `geom_sf()`? Because were plotting just *sac.city.tracts.c* on the map.  In the examples above, we were plotting both *sac.city.tracts.c* and *sac.city*.  In other words, we were plotting two spatial datasets.  In this case, we had to leave `ggplot()` empty and specify the **sf** objects within `geom_sf()`.

We can also specify a title (as well as subtitles and captions) using the `labs()` function.  

```{r}
ggplot(sac.city.tracts.c) +
  geom_sf(aes(fill = medincome)) +
  labs(title = "Median income in Sacramento City Tracts")  
``` 


We can make further layout adjustments to the map. Don't like a blue scale? You can change it using the `scale_fille_gradient()` function. We can also eliminate the gray tract border colors to make the fill color distinction clearer.  We do this by specifying `color = NA` inside `geom_sf()`. We can also get rid of the gray background by specifying a basic black and white theme using `theme_bw()`.

```{r}
ggplot(sac.city.tracts.c) +   
  geom_sf(aes(fill = medincome), color = NA) +
  scale_fill_gradient(low= "white", high = "red") +  
  labs(title = "Median income in Sacramento City Tracts",
       caption = "Source: American Community Survey") +  
  theme_bw()
```

I'm not a big fan of the border, the gridlines, and the geographic coordinate labels.  The function `theme()` controls these features.  I eliminate these features from the map, along with deleting the legend title (it's redundant because we already specify that were mapping median income in the title) by specifying `name = ""` in `scale_file_gradient()`.

```{r}
ggplot(sac.city.tracts.c) +
  geom_sf(aes(fill = medincome), color = NA) +
  scale_fill_gradient(low= "white", high = "red",  name ="") + 
  labs(title = "Median income in Sacramento City Tracts",
       caption = "Source: American Community Survey") +  
  theme( axis.text =  element_blank(),
    axis.ticks =  element_blank(),
    panel.background = element_blank())
```      


<div style="margin-bottom:25px;">
</div>
### **tmap**
\

Whether one uses the **tmap** or **ggplot2** is a matter of taste, but let's spend more time on **tmap** given that our textbook resource GWR spends more attention to this function. 

Similar to **ggplot2**, **tmap** is a series of functions that build on one another. The foundation is `tm_shape()` which acts like `ggplot()`.  You then build on `tm_shape()` by adding one or more elements, in particular `tm_polygons()`. All additional functions take on the form of `tm_`.  Check the full list of `tm_` elements [here](https://www.rdocumentation.org/packages/tmap/versions/2.0/topics/tmap-element).

Let's make a choropleth map of median household income in the Sacramento metropolitan area. 

```{r}
tm_shape(sac.metro.tracts.w) +
  tm_polygons(col = "medincome", style = "quantile")
```

The argument `col = "medincome"` tells R to shade the tracts by the variable *medincome*.  The argument `style = "quantile"` tells R to break up the shading into quantiles, or equal groups of 5.  I find that this is where **tmap** offers a distinct advantage over **ggplot2** in that users have greater control over the legend and bin breaks.  **tmap** allows users to specify algorithms to automatically create breaks with the `style` argument.  Seven of the most useful break styles are described in the bullet points below (taken from GWR):

* `style = pretty`, the default setting, rounds breaks into whole numbers where possible and spaces them evenly
* `style = equal` divides input values into bins of equal range, and is appropriate for variables with a uniform distribution (not recommended for variables with a skewed distribution as the resulting map may end-up having little color diversity)
* `style = quantile` ensures the same number of observations fall into each category (with the potential down side that bin ranges can vary widely)
* `style = jenks` identifies groups of similar values in the data and maximizes the differences between categories
* `style = cont` (and `order`) present a large number of colors over continuous color field, and are particularly suited for continuous rasters (order can help visualize skewed distributions)
* `style = sd` divides the values by standard deviations above and below the mean.
* `style = cat` was designed to represent categorical values and assures that each category receives a unique color

Don't like the color? Palettes define the color ranges associated with the bins and determined by the `style` arguments.  We can change the color scheme by using the argument `palette`.

```{r}
tm_shape(sac.metro.tracts.w) +
  tm_polygons(col = "medincome", style = "quantile",palette = "Reds", 
              border.alpha = 0, title = "Median income") 
```

Here, I used the color scheme "Reds". See Ch. 8.2.4 in GWR for a fuller discussion on color and other schemes you can specify.

Also notice two additional arguments in the above code. `border.alpha` specifies the transparency of the polygon borders, which I set to 0 to indicate totally transparent.  The argument `title` specifies the title of the legend.

<div style="margin-bottom:25px;">
</div>
### **Scale bar and arrow**
\

We need to add other key elements to the map.  First, the scale bar, which you can add using the function `tm_scale_bar()`

```{r}
tm_shape(sac.metro.tracts.w, unit = "mi") +
  tm_polygons(col = "medincome", style = "quantile",palette = "Reds", 
              border.alpha = 0, title = "Median income") +
  tm_scale_bar(breaks = c(0, 10, 20), size = 1, position = c("left", "bottom")) 
```

The argument `breaks` tells R the distances to break up and end the bar.  The argument `position` places the scale bar on the bottom left part of the map. Note that the scale is in miles (were in America!).  The default is in kilometers (the rest of the world!), but you can specify the units within `tm_shape()` using the argument `unit`.
  
Next element is the north arrow, which we can add using the function `tm_compass()`.  You can control for the type, size and location of the arrow within this function.  I place a 4-star arrow on the top left of the map.

```{r}
tm_shape(sac.metro.tracts.w, unit = "mi") +
  tm_polygons(col = "medincome", style = "quantile",palette = "Reds", 
              border.alpha = 0, title = "Median income") +
  tm_scale_bar(breaks = c(0, 10, 20), size = 1, position = c("left", "bottom")) +
  tm_compass(type = "4star", position = c("left", "top")) 
```

<div style="margin-bottom:25px;">
</div>
### **Map layout**
\

We can make the map *prettier* by changing a variety of layout settings using the function `tm_layout()`.  This function is similar to `theme()` in `ggplot()`.  Check the help documentation for `tm_layout()` to see the complete list of settings.  Also see examples in Ch. 8.2.5 in GWR.  Let's change a few things to our map.

```{r, message=FALSE, warning = FALSE, results = "hide"}
sac.map <- tm_shape(sac.metro.tracts.w, unit = "mi") +
  tm_polygons(col = "medincome", style = "quantile",palette = "Reds", 
              border.alpha = 0, title = "") +
  tm_scale_bar(breaks = c(0, 10, 20), size = 1, position = c("left", "bottom")) +
  tm_compass(type = "4star", position = c("left", "top")) + 
  tm_layout(main.title = "Median income in Sacramento Metropolitan Area Tracts",
            main.title.size = 0.95, frame = FALSE)
sac.map
```

I did a few things

* I added a title using the argument `main.title`
* I made sure the title fits inside the map using `main.title.size`
* I eliminated the frame around the map using the argument `frame = FALSE`
* I eliminated the legend title by specifying `title = ""` inside `tm_polygons()`

Also notice that I saved the map into an object called *sac.map*.  R is an object-oriented program, so *everything* you *make* in R are objects that can be saved for future manipulation.  This includes maps.  And future manipulations of a saved map includes adding more `tm_*` functions to the saved object, such as `sac.map + tm_layout(your changes here)`.

What does a map of average household income look like by council district?

```{r, message=FALSE, warning = FALSE, results = "hide"}
tm_shape(cdist.sum, unit = "mi") +
  tm_polygons(col = "medinc", style = "quantile",palette = "Reds", 
              border.alpha = 0, title = "") +
  tm_scale_bar(breaks = c(0, 1, 2), size = 1, position = c("left", "bottom")) +
  tm_layout(main.title = "Median income in Sacramento
            Council Districts",  main.title.size = 0.95, frame = FALSE,
              legend.position = c("right","top"))
```


<div style="margin-bottom:25px;">
</div>
### **Faceted maps**
\

Remember last week we created faceted plots using `ggplot()`? We can do the same for maps. Faceted maps, also referred to as ‘small multiples’, are composed of many maps arranged side-by-side, and sometimes stacked vertically. Facets enable the visualization of how spatial relationships change with respect to another variable, such as time or geography. Typically all individual facets in a faceted map contain the same geometry data repeated multiple times, once for each column in the attribute data.

To create a faceted map, use the function `tm_facets()`.  For example, I created choropleth maps of tract median income for the Sacramento metropolitan area by county using the following code.

```{r warning=FALSE}
tm_shape(sac.metro.tracts.w, unit = "mi") +
  tm_polygons(col = "medincome", style = "quantile",palette = "Reds", 
              border.alpha = 0, title = "Median income") +
    tm_facets(by = "county", free.coords = FALSE)+
    tm_style_grey()
```

I didnt include all the map accoutrements such as the scale and arrow so you can clearly see how faceting works.  The `by` argument specifies the variable (in quotes) that you want to facet.  The `free.coords` argument specifies if each map has its own bounding box (which it doesn't since were using the same layer for all).

<div style="margin-bottom:25px;">
</div>    
### **Saving maps**
\

You can save your maps a couple of ways.

1. On the plotting screen where the map is shown, click on *Export* and save it as either an image or pdf file.
2. Use the function `tmap_save()`

For option 2, we can save the map object *sac.map* as such

```{r warning=FALSE, message=FALSE}
tmap_save(sac.map, "saccityinc.jpg")
```

Specify the **tmap** object and a filename with an extension. It supports `pdf`, `eps`, `svg`, `wmf`, `png`, `jpg`, `bmp` and `tiff`.  The default is `png`.  Also make sure you've set your directory to the folder that you want your map to be saved in.  

<div style="margin-bottom:25px;">
</div>
### **Interactive maps**
\

So far we've created static maps. That is, maps that don't "move".  But, we're all likely used to Google or Bing maps - maps that we can move around and zoom into.  You can make interactive maps in R using the package **tmap**.  This is another benefit of using **tmap** over **ggplot2** - the latter does not provide interactivity.

To make your tmap object interactive, use the function `tmap_mode()`

```{r, warning = FALSE, message = FALSE}
tmap_mode("view")
sac.map
```

Now that the interactive mode has been ‘turned on’, all maps produced with `tm_shape()` will launch.

Besides interactivity, another important benefit of `tmap_mode()` is that it provides a basemap.  The function of a basemap is to provide background detail necessary to orient the location of the map.  In the static maps we produced above, the Sacramento metropolitan area was sort of floating in white space.  As you can see in the interactive map above we've added geographic context to the surrounding area. 

The default basemap in `tmap_mode()` is CartoDB.Positron.  You can change the basemap through the `tm_view()` function.  For example, let's change the basemap to an [OpenStreetMap](https://www.openstreetmap.org/).

```{r warning=FALSE, message=FALSE}
sac.map + tm_view(basemaps="OpenStreetMap")
```

For a complete list of basemaps with previews, see [here](http://leaflet-extras.github.io/leaflet-providers/preview/).  There are a lot of cool ones, so please test them out.

You can save your interactive map using the same methods described above. To switch back to plotting mode (noninteractive), type in 

```{r}
tmap_mode("plot")
```


***


Website created and maintained by [Noli Brazil](https://nbrazil.faculty.ucdavis.edu/)